<!-- Do not edit this file. It is automatically generated by API Documenter. -->

[Home](./index.md) &gt; [reselect](./reselect.md) &gt; [unstable\_autotrackMemoize](./reselect.unstable_autotrackmemoize.md)

## unstable\_autotrackMemoize() function

Uses an "auto-tracking" approach inspired by the work of the Ember Glimmer team. It uses a Proxy to wrap arguments and track accesses to nested fields in your selector on first read. Later, when the selector is called with new arguments, it identifies which accessed fields have changed and only recalculates the result if one or more of those accessed fields have changed. This allows it to be more precise than the shallow equality checks in `lruMemoize`<!-- -->.

\_\_Design Tradeoffs for `autotrackMemoize`<!-- -->:\_\_ - Pros: - It is likely to avoid excess calculations and recalculate fewer times than `lruMemoize` will, which may also result in fewer component re-renders. - Cons: - It only has a cache size of 1. - It is slower than `lruMemoize`<!-- -->, because it has to do more work. (How much slower is dependent on the number of accessed fields in a selector, number of calls, frequency of input changes, etc) - It can have some unexpected behavior. Because it tracks nested field accesses, cases where you don't access a field will not recalculate properly. For example, a badly-written selector like:

```ts
     createSelector([state => state.todos], todos => todos)
```
that just immediately returns the extracted value will never update, because it doesn't see any field accesses to check.

\_\_Use Cases for `autotrackMemoize`<!-- -->:\_\_ - It is likely best used for cases where you need to access specific nested fields in data, and avoid recalculating if other fields in the same data objects are immutably updated.

**Signature:**

```typescript
export declare function autotrackMemoize<Func extends AnyFunction>(func: Func): Func & Simplify<DefaultMemoizeFields>;
```

## Parameters

<table><thead><tr><th>

Parameter


</th><th>

Type


</th><th>

Description


</th></tr></thead>
<tbody><tr><td>

func


</td><td>

Func


</td><td>

The function to be memoized.


</td></tr>
</tbody></table>
**Returns:**

Func &amp; Simplify&lt;[DefaultMemoizeFields](./reselect.defaultmemoizefields.md)<!-- -->&gt;

A memoized function with a `.clearCache()` method attached.

## Example 1

<caption>Using `createSelector`</caption>

```ts
import { unstable_autotrackMemoize as autotrackMemoize, createSelector } from 'reselect'

const selectTodoIds = createSelector(
  [(state: RootState) => state.todos],
  (todos) => todos.map(todo => todo.id),
  { memoize: autotrackMemoize }
)
```

## Example 2

<caption>Using `createSelectorCreator`</caption>

```ts
import { unstable_autotrackMemoize as autotrackMemoize, createSelectorCreator } from 'reselect'

const createSelectorAutotrack = createSelectorCreator({ memoize: autotrackMemoize })

const selectTodoIds = createSelectorAutotrack(
  [(state: RootState) => state.todos],
  (todos) => todos.map(todo => todo.id)
)
```

